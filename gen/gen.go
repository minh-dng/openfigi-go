package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log/slog"
	"net/http"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"
)

const folder = "constants"

const hashSetFile = "values.go"

const enumTemplate = `// Code generated by go generate; DO NOT EDIT.
package ` + folder + `

const (
{{- range .Constants }}
    {{ .Name }} = "{{ .Value }}"
{{- end }}
)
`

const hashSetTemplate = `
var {{ .Prop }}Set = sets.New(
{{- range .Values }}
	"{{ . }}",
{{- end }}
)
`

func main() {
	props := []string{
		"idType",
		"exchCode",
		"micCode",
		"currency",
		"marketSecDes",
		"securityType",
		"securityType2",
		"stateCode",
	}

	if err := os.MkdirAll(folder, os.ModePerm); err != nil {
		panic(err)
	}

	// Write hashSetFile header
	hashSetHeader := `// Code generated by go generate; DO NOT EDIT.
	package openfigi
	
	import "k8s.io/apimachinery/pkg/util/sets"
	`

	formatted, err := format.Source([]byte(hashSetHeader))
	if err != nil {
		panic(err)
	}

	if err := os.WriteFile(hashSetFile, formatted, 0644); err != nil {
		panic(err)
	}

	for _, prop := range props {
		values := getValues(prop)
		slog.Info(fmt.Sprintf("Generating %s with %d values", prop, len(values)))
		enumGen(prop, values)
		hashSetGen(prop, values)
	}
}

func hashSetGen(property string, values []string) {
	tmpl, err := template.New("hashset").Parse(hashSetTemplate)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, struct {
		Prop   string
		Values []string
	}{
		property, values,
	}); err != nil {
		panic(err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	f, err := os.OpenFile(hashSetFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	if _, err := f.Write(formatted); err != nil {
		panic(err)
	}
}

type keyVal struct {
	Name  string
	Value string
}

func enumGen(property string, values []string) {
	var constants []keyVal
	for _, v := range values {
		// Remove non-ASCII characters except for valid Unicode letters
		re := regexp.MustCompile(`[^\p{L}\p{N}_]`)
		cleanedName := re.ReplaceAllString(v, "")
		// Remove leading non-alphabetic characters
		// re = regexp.MustCompile(`^[^\p{L}\p{N}_]+`)
		// cleanedName = re.ReplaceAllString(cleanedName, "")
		// Remove spaces
		cleanedName = strings.ReplaceAll(cleanedName, " ", "")
		// Replace special characters with underscores
		re = regexp.MustCompile(`[^\p{L}\p{N}]`)
		cleanedName = re.ReplaceAllString(cleanedName, "_")
		if cleanedName == "" {
			cleanedName = "UNKNOWN"
		}

		constants = append(constants, keyVal{
			Name:  fmt.Sprintf("%s_%s", strings.ToUpper(property), cleanedName),
			Value: v,
		})
	}

	tmpl, err := template.New("constants").Parse(enumTemplate)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, struct {
		Constants []keyVal
		Prop      string
	}{constants, property}); err != nil {
		panic(err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}

	if err := os.WriteFile(filepath.Join(folder, property+".go"), formatted, 0644); err != nil {
		panic(err)
	}
}

func getValues(property string) []string {
	url := fmt.Sprintf("https://api.openfigi.com/v3/mapping/values/%s", property)
	slog.Info(fmt.Sprintf("GET %s", property))
	resp, err := http.Get(url)
	if err != nil {
		panic(fmt.Sprintf("Failed to get %s: %v. Make sure to not exceed rate limit", property, err))
	}
	defer resp.Body.Close()

	var result struct {
		Values []string `json:"values"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		panic(err)
	}

	return result.Values
}
